
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>小朋友艾沫雨和老朋友李默玉 - 小朋友艾沫雨</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="大家一起快乐摸鱼！,Copyright © 2019 ChenKaidao All Right Reserved
"> 
    <meta name="author" content="ckd"> 
    <link rel="alternative" href="atom.xml" title="小朋友艾沫雨" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">小朋友艾沫雨</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="https://encofcomic.github.io"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">计算机程序的构造和解释笔记</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">计算机程序的构造和解释笔记</h1>
        <div class="stuff">
            <span>三月 18, 2019</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Notes/">Notes</a></li></ul>


        </div>
        <div class="content markdown">
            <ul>
<li>计算机程序的构造和解释 #textbook <ul>
<li>构造过程抽象<ul>
<li>计算过程<ul>
<li>操作一些被称为数据到抽象数据</li>
<li>用程序到过着模式，以指导这类这类过程的进行</li>
</ul>
</li>
<li>程序设计的基本元素<ul>
<li>基本表达形式</li>
<li>组合的方法</li>
<li>抽象的方法</li>
</ul>
</li>
<li>define<ul>
<li>最简单的抽象方法，用一个简单的名字去引用一个组合运算的结果</li>
<li>我们可以将值与符号关联，而后又能提取出这些值，这意味着解释器必须维护某种储存能力，以便保持有关的名字-值对偶的轨迹。</li>
<li>这种储存被称为环境（全局环境）</li>
</ul>
</li>
<li>过程作为黑箱抽象<ul>
<li>递归的意思是，这一过程的定义给予他自身</li>
<li>我们将某一个过程看做一个“黑箱”，在它上层的过程看来，这个过程是怎么样实现的被抹去了，这个过程不如说是过程的抽象，即过程抽象</li>
<li>过程的形式参数具体的名字无关紧要，这样的名字称为约束变量，因此一个过程的定义约束了它的所有形式参数，相反，我们称参数是自由的</li>
<li>我们允许一个过程类有一些内部定义，是他们是局部与这一过程的，为了将某种子过程局部化，将它们隐藏到父过程中，这种嵌套的定义称为块结构</li>
</ul>
</li>
<li>过程与它们所产生的计算<ul>
<li>一个过程就是一种模式，它描述了一个计算过程的局部演化方式。</li>
<li>一个递归计算过程构造期一个推迟进行的操作所形成的链条，收缩阶段表现为这些运行的实际执行。</li>
<li>推迟执行的操作链条的长度也就是为保存其轨迹所需要的信息量，这个长度随着n值而线性增长，这样的计算过程成为一个线性递归过程</li>
<li>迭代计算过程就是那种其状态可以用固定数目的状态变量描述的计算过程；与此同时又存在着一套固定的规则，描述您计算过程从一个状态到下一个状态转换时这些变量的更新方式；还有一个（可能有的）结束检测，描述这一计算过程应该终止的条件。</li>
<li>迭代过程只需由几个程序变量即可提供一个完整的计算状态描述，而对于递归计算过程而言，它需要另外一些由解释器维持着的在所推迟的运算所形成的链条里的漫游中这一计算过程固定递归次数。</li>
<li>当我们所一个过程是递归的时候，论述的是一个语法形式上的试试，说明这个过程的定义中（直接或者间接的）引用了该过程本身。再说某一计算过程具有某种模式时，我们说的是这一计算过程的进展方式。</li>
<li>树形递归：斐波那契数列的递归过程</li>
<li>人们希望能设计出一种“灵巧编译器”，使之能将一个树形递归的过程翻译为一个能计算出同样结果的更有效的过程</li>
<li>我们用增长的阶来描述某一计算过程所需资源的粗略度量情况<ul>
<li>令n是一个参数，他能作为问题规模的一个度量，令R(n)是一个计算过程在处理规模为n的问题时所需要的资源量</li>
<li>我们称R(n)具有theta( f(n) )的增长阶</li>
</ul>
</li>
</ul>
</li>
<li>用高阶函数做抽象<ul>
<li>为公共的模式命名，建立抽象，而后直接在抽象的层次上工作。过程提供了这种能力</li>
<li>我们需要构造出一些过程，让他们以过程作为参数或者以过程作为返回值，这类能操作过程的过程称为高阶过程</li>
<li>过滤器：在计算过程中只组合起由给定范围得到的项里那些满足特定条件的项</li>
</ul>
</li>
</ul>
</li>
<li>构造数据抽象<ul>
<li>将数据对象组合起来，形成复合数据，复合数据能够提升我们在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。</li>
<li>如果我们可以将有理数本身当作对象的方式下操作他们，那么也就可能把处理有理数的那些程序部分，与有理数如何表示的细节隔离开，形成一种称为数据抽象的设计方法学</li>
<li>数据抽象可以在程序的不同部分之间建立起适当的抽象屏障，语言中还应提供了一些“粘合剂”，让我们可以把一些数据对象组合起来，形成更复杂的数据对象</li>
<li>我们将创建一些比基本过程更复杂的过程，以能够对通过参数送来的任何种类的数据执行适当的操作，甚至直接操作复合对象</li>
<li>用于组合数据对象的黏合剂不但能用于组合基本的数据对象，同样也可以用于复合的数据对象，另一方面，一个重要的思想是闭包的概念，复合数据对象能够成为以混合与匹配的方式组合程序模块的方便界面。</li>
<li>而后我们要引进符号表达式，对于一种给定的数据结构，也可以有许多方式将其表示为简单对象的组合。</li>
<li>通用型操作是为了满足处理不同类型数据的时候维持模块性，特别的我们将介绍数据导向的程序设计，他能允许我们孤立地设计每一种数据表示，而后用添加的方式将它们组合进去</li>
<li>数据抽象导引<ul>
<li>基础假设<ul>
<li>除了具体完成当前工作所必要的东西之外，不对所用数据做任何多余的假设。</li>
<li>与此同时，一种“具体”的数据所表示的定义，也应该与程序中使用数据的方式无关，这样两个部分称为选择函数和构造函数。</li>
<li>为了实现一种组合的数据抽象，我们提供了一种称为序对的复合结构，取两个参数，返回一个包含这两个参数作为其成分的复合数据对象。再用两个过程来提取出其中的各个部分。用这种序对构造起来的数据对象称为表数据结构</li>
</ul>
</li>
<li>抽象屏障把使用数据抽象的程序与构造数据抽象的程序分开来。</li>
<li>数据可以定义为一组适当的选择函数和构造函数，以及为了使这些过程成为一套合法表示，所必须满足的一组特定条件</li>
</ul>
</li>
<li>层次性数据和闭包性质<ul>
<li>在一种盒子与指针表达方式中，每个对象表示为一个指向盒子的指针</li>
<li>我们可以构建元素本身也是序对的序对，这种能力成为con的闭包性质。一般说某种组合数据对象的操作满足闭包性质，那就是说，通过它组合起数据对象得到的结果本身还可以通过同样的操作再进行组合。</li>
<li>在这里 我们用表专指那些有表尾结束标记的序对的链。与此相对应，用术语表结构指所有的序对构造起来的数据结构，而不仅是表</li>
<li>序列是一批数据对象的一种有序汇集。通过嵌套的cons形成的这样一个序对的序列称为一个表。</li>
<li>car看作选取表的第一项的操作，cdr看作是选取表中除去第一项之后剩下的所有项形成的子表，cons用于构造表，它在原有的表前面增加一个元素。</li>
<li>nil的值用于表示序对的链结束，也可以当作一个不包含任何元素的序列，空表。</li>
<li>本书的作者参加过许多语言标准化方面的无益口角，真是希望能完全避免这些东西。</li>
<li>高阶过程map有一个过程参数和一个表参数返回将这一过程应用于表中各个元素得到的结果形成的表</li>
<li>元素本身也是序列的序列，可以看作是树。序列里的元素就是树的分支，而那些本身也是序列的元素就形成了书中的子树。</li>
<li>想要组织好一种程序，使之能够更清晰的反应上面信号流的结构，最关键的一点就是将注意力集中在处理过程中从一个步骤流向下一个步骤的“信号”。如果我们用一些表来表示这些信号，那么就可以利用表操作实现每一步骤的处理。</li>
<li>将程序表示为一些针对序列的操作的价值在于能帮助我们得到模块化的程序设计，也就是说，得到由一些比较独立的片段组合构成的设计。通过提供一个标准部件的库，并使这些部件都有着一些能以各种灵活方式相互连接的约定界面，将能进一步推动人们去做模块化的设计</li>
<li>纪念William Barton Rogers MIT的创始人和第一任校长。他说：“强制性的区分实践工作者和科学工作者是完全无益的，当代的所有经验已经证明这种区分也是完全没有价值的。”</li>
<li>分层设计这一概念说的是，一个复杂的系统应该通过一些列的层次构造出来，为了描述这些层次，需要使用一系列的语言。构造各个层次的方式，就是设法组合起作为这一层次中部件的各种基本元素、组合手段，还有对该层次中的适当细节做抽象的手段。</li>
<li>分层设计有助于使程序更加强健，也就是说，使我们更有可能在给定规范发生一些微小改变时，只需对程序做少年的更改。</li>
</ul>
</li>
<li>符号数据<ul>
<li>一个单引号的意义就是引用下一个对象</li>
<li>允许在一个语言中使用引号，将会极大地损害根据简单词语在语言中做推理的能力，因为它破坏了对等的东西可以相互替换的观念。引号是很有威力的东西，因为它使我们可以构造起一种能操作其他表达式的表达式。</li>
<li>在scheme语言中，使用引号违背了我们语言中所有复合表达式都应该由括号限定，都具有表的形式的普遍性原则。为了恢复一致性，我们引入quote这种特殊形式，引号只不过是一种将下一完整表达式用（quote <expression>)形式包裹起来的单字符缩写形式。这一点非常重要，因为它维持了 我们的原则：解释器看到的所有表达式都可以作为数据对象去操作。</expression></li>
<li>现在有了一种表示代数表达式的方式，我们一定能判断出某个表达式是否为一个和式、乘式、常量或者变量，也能提取出表达式里的各个部分。</li>
<li>在前面的实例中，我们都采取了某种选择，在构造或者选择成员时去简化（约简）有关的表示，除此之外，选择用表的形式来表达这些结构都是直截了当的。限制啊我们要转到集合的表示问题，此时，表示方法就不那么显然了。</li>
<li>非形式的说，一个集合就是一些不同对象的汇集。要给出更精确的定义，我们可以利用数据抽象的办法，也就是说，用一组可以用于“集合”的操作来定义他们。（见103页脚注103）</li>
<li>如果将集合元素安排成一棵树的形式，树中每个节点保存集合中的一个元素，称为该节点的“数据项”，它还链接到另外的两个结点（可以为空）。其中“左边”的链接所指向的所有元素均小于本结点的元素，而右边的结点都大于本结点里的元素。我们对一个合法表示的要求就是，位于左子树里的所有元素都小于本结点里的数据项，而位于右子树里的所有元素都要大于它。</li>
<li>（可以参见关于平衡树及其算法的有关数据结构的文献）</li>
<li>Huffman树<ul>
<li>对于符号所出现的相对频度与构造树的消息相符的消息而言，这样产生出的编码确实是最好的变长编码</li>
<li>构造过程从叶结点的集合开始，这种结点中包含各个符号与他们出现的频度，这就是开始构造编码的初始数据</li>
<li>现在要找出两个具有最低权重的叶并归并它们，产生出一个以这两个结点为左右分支的结点，新结点的权重就是那两个结点的权重之和，删除原来那两个结点，用这个新结点代替它们</li>
<li>在其中的每一步都归并两个具有最小权重的结点，重复这一过程直至集合中只剩下一个结点时，过程中止，而这个结点就是树根</li>
<li>在归并两个结点做出一棵树时，树的权重就是这两个结点的权重之和，其符号集就是两个结点的符号集的并集</li>
</ul>
</li>
</ul>
</li>
<li>抽象数据的多重表示<ul>
<li>数据抽象屏障是控制复杂性的强有力工具，通过对数据对象基础所表示的屏蔽，我们就可以将设计一个大程序的任务，分割为一组可以分别处理的较小任务。但是这种数据抽象还不够强大有力，因为数据对象的“基础表示”并不一定总有意义。从一个角度看，对于一个数据抽象也可能存在多种有用的表示方式，我们也希望所设计的系统能处理多种表示形式，并能对任意表示形式作出恰当的工作</li>
<li>除了需要将表示与使用相隔离的数据抽象屏障之外，我们还需要有抽象屏障去隔离互不相同的程序选择，以便允许不同的设计选择在同一个程序里共存。进一步说，由于大型程序往往是通过组合起一些现存模块构造起来的，而这些模块又是独立设计的，我们也需要一些方法使程序员可能逐步将许多模块结合成一个大型系统，而不必去重构这些模块</li>
<li>我们需要去处理数据，使他们可能在一个程序的不同部分中采用不同的表示方式。这就需要我们去构造通用型过程——也就是那种可以在不只一种数据表示上操作的过程。</li>
<li>这其中的主要技术是让它们在带有类型标志的数据对象上工作，也就是说，让这些数据对象包含着它们应该如何处理的明确信息。我们还要讨论数据导向的程序设计，这是一种用于构造采用了通用型操作的系统的技术</li>
<li>由选择函数和构造函数形成的抽象屏障使我们可以把为自己所用数据对象选择具体表示形式的事情尽量往后推，而且还能保持系统设计的最大灵活性。</li>
<li>检查一个数据项的类型，并据此去调用某个适当过程称为基于类型的分派。</li>
<li>现在我们需要的是一种能够将系统设计进一步模块化的方法，一种称为数据导向的程序设计的编程技术提供了这种能力。在需要处理的是针对不同类型的一集公共通用型操作时，事实上，我们正是在处理一个二维表格，其中的一个维上包含着所有的可能性操作，另一个维就是所有的可能类型。表格中的一些项目是一些过程，它们针对作为参数的每个类型实现每一个操作。</li>
<li>在数据导向的程序设计里，最关键的想法是通过显式处理操作-类型表格的方式，管理程序中的各种通用型操作。我们在之前所用的程序设计风格，是一种基于类型分派的组织方式，其中让每个操作管理自己的分派。从效果上来看，这种方式就是将操作-类型表格分解为一行一行，每个通用型过程表示表格中的一行。另一种实现策略是将表格按列进行分解，不是采用一批“智能操作”去基于数据类型进行分派，而是采用“智能数据对象”，让他们基于操作名完成所需的分派工作。</li>
<li>如果我们想这样做，所需要做的就是做出一种安排，将每一个数据对象表示为一个过程。它以操作的名字作为输入，能够去执行制定的操作。这种风格的程序设计称为消息传递，这一名字源于将数据对象设想为一个实体，它以“消息”的方式接收到所需操作的名字。</li>
</ul>
</li>
<li>带有通用型操作的系统<ul>
<li>通过通用型界面过程，将描述数据操作的代码列街道几种不同的表示上。现在我们将使用同样的思想，不但定义出能够在不同表示上的通用操作，还能让定义针对不同参数种类的通用型操作</li>
<li>在一个大型的复杂系统里可能有很多层次，每层与下一层次之间的链接都借助于一些通用型操作，当一个数据对象被“向下”传输时，用于引导它进入适当程序包的最外层标志被剥除，下一层次的标志（如果有的话）变成可见的，并将用于下一次分派。</li>
<li>至今定义的所有运算，都把不同数据类型看作相互完全分离的东西，但是定义出能够跨过类型界限的操作也很有意义。我们必须以一种经过精心设计的可控方式去做这件事情，以便我们在支持这种操作的同时有没有严重的损害模块间的分界。其中一种方式就是为每一种类型组合的合法运算设计一个特定过程。</li>
<li>这一技术确实可以用，但也非常麻烦。对于这样的一个系统，引进一个新类型的代价就不仅仅需要构造出针对这一类型的所有过程的包，还需要构造并安装好所有实现跨类型操作的过程。后一件事情所需要的代码很容易就会超过定义类型本身所需的那些操作。这种方法也损害了以添加的方式组合独立开发的程序包的能力，要求在对独立程序包工作时，必须同时关注其他的程序包。</li>
<li>常常存在一些方式，是我么可以把一种类型的对象看作另一种类型的对象，这种过程就称之为强制，将能这样做的基础是，类型之间的适当转换只依赖于类型本身，而不依赖于所实现应用的操作</li>
<li>我们实际有的是一个所谓的类型的层次结构，A是B的子类型，也就是说，适用于B的所有操作也都适用于A，与此相对应，我们也说B是A的一个超类型，这样一个叠加起来的结构称为一个类型塔。其中每个类型能够“继承”其超类型中定义的所有操作，而每个类型都能通过某种方式来“下降”到它的子类型</li>
<li>但是存在一种多重超类型，例如A是B的子类型，也是C的子类型，C又有D作为它的子类型，意味着并不存在一种唯一方式在层次结构中去“提升”一个类型</li>
<li>在设计大型系统中，处理好一大批相互有关的类型而同时能保持模块性，这是一个非常困难的问题，也是当前正在继续研究的领域。这句话现在和20年前提出来的时候同样正确，这在哲学中称为“本体论”。</li>
<li>一个高效而优美的计算多项式GCD的方法由Richard Zippel 1979 发明，这是一个概率算法</li>
</ul>
</li>
</ul>
</li>
<li>模块化、对象和状态<ul>
<li>有效的程序组合还需要一些组织原则，使这些系统能够“自然的”划分为一些具有内聚力的部分，使这些部分可以分别进行开发和维护。</li>
<li>第一种策略将注意力集中在对象上，将一个大型系统看成一大批对象，他们的行为可能随着时间的紧展而不断变化。另一种组织策略将注意力集中在流过系统的信息流上，非常像电子工程师观察一个信号处理系统。</li>
<li>我们必须关注计算对象可以怎样变化而又同时保持其标示，这将迫使我们转向更机械式的，理论上也更不容易把握的计算的环境模型。流方式特别能够用于松解在我们的模型中对时间的模拟与计算机求值过程中各种事件发生的顺序。我们将通过一种称为延时求值的技术做到这一点。</li>
<li>赋值与局部状态<ul>
<li>所谓一个对象“有状态”，也就是说它的行为收到他的历史的影响。我们可以用一个或几个状态变量刻画一个对象的状态，在他们之中维持着有关这一对象的历史，既能够确定该对象当前行为的充分信息。</li>
<li>在一个有许多对象组成的系统里，其中这些对象极少会是完全独立的。所谓交互就是建立起一个对象的状态变量与其他对象的状态变量之间的联系。确实，如果一个系统中的状态变量可以分组，形成一些内部紧密结合的子系统，每个系统与其他子系统之间只存在分散联系，此时将这个系统看作是由一些独立对象组成的观点就会特别有用。</li>
<li>对于一个系统的这种观点，有可能在成为组织这一系统的计算模型的有力框架。要使这样的一个模型成为模块化的，就要求他能分解为一批计算对象，使他们能够模拟系统里的实际对象。每一个计算对象必须有他自己的一些局部状态变量，用于描述实际对象的状态。如果我们希望通过程序设计语言里常规的符号名字去模拟换状态变量，那么语言里就必须提供一个赋值运算符，使我们能用它去改变与一个名字相关联的值。</li>
<li>到现在为止，我们看到的所有过程都可以看作一些可计算的数学函数的描述，对一个过程的调用将计算出相应函数作用于给定参数应得到的值，用同样的实际参数两次调用一个过程，总会产生出相同的结果。</li>
<li>按照程序设计语言的行话，局部变量是被封装在了过程里面，封装也反映了通常所谓隐藏原理的一般性系统设计原则：通过将系统中不同的部分保护起来，使系统更模块化，更强健。</li>
<li>应用一个过程应该被解释为：在将过程的形式参数用对应的值取代之后求值这一过程的体。</li>
<li>随机选择的意思并不清楚，我们的意思是能够产生出一系列的数，这一序列具有均匀分布的数学性质</li>
<li>从一个复杂计算过程中几部分的观点看，其他部分都像是在随着时间不断变化，他们隐藏起自己的随时间变化的内部状态。假设我们希望写出一个计算机程序，反应这种系统分解，那么就需要让计算对象的行为随时间变化，用局部状态变量去模拟系统的状态，用对这些变量的赋值去模拟状态的变化</li>
<li>进一步地说，任何具有“漂亮”数学性质的简单模型，都不可能继续适合作为处理程序设计语言里的对象和赋值的框架了。不用任何赋值的程序设计称为函数式程序设计。现在的一个变量索引着一个可以保存值的位置，而储存在那里的值也是可以改变的。</li>
<li>如果一个语言支持在表达式里“同一的东西可以相互替换”的观念，这样的替换不会改变有关表达式的值，这个语言就称为是具有应用透明性。如果没有有关“同一”的某些先验观念，我们也就不可能确定“变化”，而不能看到变化的影像又无法确定同一性。</li>
<li>与函数式程序设计相对应的，广泛采用赋值的程序设计被称为命令式程序设计。</li>
</ul>
</li>
<li>求值的环境模型<ul>
<li>此时的变量必须以某种方式指定了一个“位置”，相应的值可以储存在那里。在我们的新求值模型里，这种位置将维持在称为环境的结构中。</li>
<li>一个环境就是框架的一个序列，每个框架是包含着一些约束的一个表格（可能为空），这些约束将一些变量名字关联于相应的值，每个框架还包含着一个指针，指向这一框架的外围环境。如果由于当前讨论的目的，将相应的框架看作是全局的，那么他将没有外围环境。一个变量相对于某个特定环境的值，也就是在这一环境中，包含着该变量第一个框架你这个变量的约束值。如果在序列中并不存在这一变量的约束，那么我们就说这个变量在该特定环境中是无约束的。</li>
<li>在一个框架里，任何变量至多只能有一个约束</li>
<li>遮蔽是指底层框架的解释会被优先采用从而忽略上层框架中的对于同名变量的解释</li>
<li>环境对于求值过程是至关重要的，因为它确定了表达式求值的上下文。实际上，在一个程序语言里，一个表达式本身根本没有任何意义，任何一个再简单的表达式其解释也要依赖于有关的操作是在某个上下文里进行的。为了描述与解释器的交互作用，我们将始终假定存在着一个全局环境，他只包含着一个框架（没有外围环境），这个环境里包含着所有关联于基本过程的符号的值，在这里的表现就是最基本的符号在全局环境中被约束到相应的基本操作过程</li>
<li>在求值的环境模型里，一个过程总是通过一个对偶，有一些代码和一个指向环境的指针组成</li>
<li>过程只能通过一种方式创建，那就是通过求值一个 lambda表达式。这样产生出的过程的代码来自这一 lambda表达式的正文，其环境就是求着这个 lambda 表达式产生出这个过程时的那个环境</li>
<li>我们永远也不要去写依赖于特定顺序的程序</li>
<li>我们可以把过程应用的环境模型总结为下面两条规则：将一个过程对象应用于一集实际参数，将构造出一个新框架，其中将过程的形式参数约束到调用时的实际参数，而后在构造起这一新环境的上下文中求值过程体。这个新框架的外围环境就是作为被应用的那个过程对象的一部分的环境</li>
<li>相对于一个给定环境求值一个lambda的表达式，将创建起一个过程对象，这个过程对象是一个序对，由该 lambda的正文和一个指向环境的指针组成，这一指针指向的就是创建这个过程对象时的环境</li>
<li>局部过程的名字不会与包容他们的过程之外的名字相互干扰这是因为这些局部过程名都是在该过程运行时创建的框架里面约束的，而不是在全局环境里约束的</li>
<li>局部过程只需将包含着他们的过程的形参作为自由变量，就可以访问该过程的实际参数，这是因为对于局部过程体的求值所在的环境是外围过程求值所在的环境的下属</li>
</ul>
</li>
<li>用变动数据做模拟<ul>
<li>为了模拟具有不断变化的状态的复合对象，我们设计出与之对应的数据抽象，使其不但包含了选择函数和构造函数，还包含一些称为改变函数的操作，这种操作能够修改有关的数据对象。定义了改变函数的数据对象称为变动数据对象</li>
<li>对于序对的改变函数，是序对能够作为构造变动数据对象的基本构件</li>
<li>用cons构造出的表结果总是序对的一个相互连接的结构，其中可能会有许多独立的序对被一些不同结构所共享</li>
<li>从理论上说，为了表现变动数据的行为，所需要的全部东西也就是赋值。只要将复制纳入这一预言，我们就引出了所有的问题，不仅是赋值，而且也包括一般性的变动对象</li>
<li>一个队列是一个序列，数据项只能从一端插入（这称作队列的末端），只能从另一端删除（前端）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="https://music.163.com/search/m/?s=K.157&type=1">
            </audio>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci data-cs data-r data-o data-a data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
